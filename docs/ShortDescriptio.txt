RANDOM::RevealAndCommit() does all the job. _rdseed64_step() can be called in C++ to get entropy.
Calling smart contract procedures is actually just sending a transaction where destination is ID of the smart contract (DAAAAAAAAAAAA... in our case), inputType is contract procedure index (=1 in our case), inputSize is non-zero (544 bytes in our case) and input data are injected between inputSize and signature.
Random.h contains structure which needs to be filled, it has the following structure:
    struct RevealAndCommit_input
    {
        bit_4096 revealedBits;
        id committedDigest;
    };

The logic is this:
First you do a commit by publishing digest of your entropy bits, then you reveal these bits.
Client sends commit-only with empty reveal, then after +3 ticks sends reveal+new commit for next round.
revealedBits reveal etrnopy for the previous commit; committedDigest is for the next reveal.
Both transactions send the configured commit amount (reveal-only is not used).
Pipeline sleeps between ticks (pipeline_sleep_ms) to reduce busy work.
Pipeline pauses when available balance is below the configured commit amount.
To prevent people from not revealing we require some security deposit to be placed, it's sent as amount
When you commit you get security deposit held by SC, after revealing in time you get your money back, otherwise they are kept by SC forever
You decide the amount yourself
Higher amount = higher reward.

Client note:
Transactions are signed and sent via the RPC broadcast-transaction endpoint.
Tick is scheduled in the future (current tick + tx_tick_offset, default 5); reveal is scheduled at +3 from that tick.
